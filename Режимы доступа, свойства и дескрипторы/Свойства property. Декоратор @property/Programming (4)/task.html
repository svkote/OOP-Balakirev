<p>Видео-разбор подвига (решение смотреть только после своей попытки): <a href="https://youtu.be/5Y9qT5grunw" rel="noopener noreferrer nofollow">https://youtu.be/5Y9qT5grunw</a></p>

<p><strong>Большой подвиг 8.</strong> Требуется реализовать программу по работе с решающими деревьями:</p>

<p style="text-align: center;"><img alt="" height="317" name="решающее дерево.png" src="https://ucarecdn.com/aba1d29f-550a-4dba-89f5-df4164284478/" width="713"></p>

<p>Здесь в каждом узле дерева делается проверка (задается вопрос). Если проверка проходит, то осуществляется переход к следующему объекту по левой стрелке (с единицей), а иначе - по правой стрелке (с нулем). И так до тех пор, пока не дойдем до одного из листа дерева (вершины без потомков).</p>

<p>В качестве входных данных используется вектор (список) с бинарными значениями: 1 - да, 0 - нет. Каждый элемент этого списка соответствует своему вопросу (своей вершине дерева), например:</p>

<p style="text-align: center;"><img alt="" height="138" name="решающее дерево x.png" src="https://ucarecdn.com/a81ebcd0-ba44-43c9-bfae-34f27bc672e1/" width="537"></p>

<p>Далее, этот вектор применяется к решающему дереву, следующим образом. Корневая вершина "Любит Python" с ней связан первый элемент вектора x и содержит значение 1, следовательно, мы переходим по левой ветви. Попадаем в вершину "Понимает ООП". С ней связан второй элемент вектора x со значением 0, следовательно, мы переходим по правой ветви и попадаем в вершину "будет кодером". Так как эта вершина конечная (листовая), то получаем результат в виде строки "будет кодером". По аналогии выполняется обработка вектора x с другими наборами значений 0 и 1.</p>

<p>Для реализации решающих деревьев в программе следует объявить два класса:</p>

<p><strong>TreeObj </strong>- для описания вершин и листьев решающего дерева;<br>
<strong>DecisionTree</strong> - для работы с решающим деревом в целом.</p>

<p>В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):</p>

<p><u>def predict(cls, root, x)</u> - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла дерева root.<br>
<u>def add_obj(cls, obj, node=None, left=True)</u> - для добавления вершин в решающее дерево (метод должен возвращать добавленную вершину - объект класса TreeObj);</p>

<p>В методе add_obj параметры имеют, следующие значения:</p>

<p>obj - ссылка на новый (добавляемый) объект решающего дерева (объект класса TreeObj);<br>
node - ссылка на объект дерева, к которому присоединяется вершина obj;<br>
left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви; False - к правой).</p>

<p>В классе <strong>TreeObj</strong> следует объявить инициализатор:</p>

<p>def __init__(self, indx, value=None): ...</p>

<p>где <u>indx</u> - проверяемый в вершине дерева индекс вектора x; <u>value</u> - значение, хранящееся в вершине (принимает значение None для вершин, у которых есть потомки - промежуточных вершин).</p>

<p>При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:</p>

<p>indx - проверяемый индекс (целое число);<br>
value - значение с данными (строка);<br>
__left - ссылка на следующий объект дерева по левой ветви (изначально None);<br>
__right - ссылка на следующий объект дерева по правой ветви (изначально None).</p>

<p>Для работы с локальными приватными атрибутами __left и __right необходимо объявить объекты-свойства с именами <strong>left </strong>и <strong>right</strong>.</p>

<p>Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):</p>

<pre><code>root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

x = [1, 1, 0]
res = DecisionTree.predict(root, x) # будет программистом
</code></pre>

<p>P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно. </p><br><br><font color="gray">Memory limit: 256 MB</font><br><font color="gray">Time limit: 15 seconds</font><br><br>