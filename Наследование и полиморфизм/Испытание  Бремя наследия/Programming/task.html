<h1>Испытание "Бремя наследия"</h1>

<p>Видео-разбор подвига (решение смотреть только после своей попытки): <a href="https://youtu.be/M_UctsRbNGA" rel="noopener noreferrer nofollow">https://youtu.be/M_UctsRbNGA</a></p>

<p>Всевидящее око начальства увидело, что вы прошли еще одну ступень в постижении глубин ООП языка Python - наследование. Вас вновь решили испытать и посмотреть, на что вы действительно способны. Тимлид (Teamleader) с широкой улыбкой протянул вам следующее задание.</p>

<h2>Техническое задание</h2>

<p>Необходимо написать универсальную основу для представления ненаправленных связных графов и поиска в них кратчайших маршрутов. Далее, этот алгоритм предполагается применять для прокладки маршрутов: на картах, в метро и так далее.</p>

<p style="text-align: center;"><img alt="" height="466" name="метро.jpg" src="https://ucarecdn.com/0951c9d3-953b-4a8e-a823-7766c5d69ceb/" width="458"></p>

<p>Для универсального описания графов, вам требуется объявить в программе следующие классы:</p>

<p><strong>Vertex</strong> - для представления вершин графа (на карте это могут быть: здания, остановки, достопримечательности и т.п.);<br>
<strong>Link</strong> - для описания связи между двумя произвольными вершинами графа (на карте: маршруты, время в пути и т.п.);<br>
<strong>LinkedGraph</strong> - для представления связного графа в целом (карта целиком).</p>

<p style="text-align: center;"><img alt="" height="228" name="LinkedGraph.png" src="https://ucarecdn.com/6527dab4-60c6-4d36-90e1-16e5a4ca5889/" width="385"></p>

<p>Объекты класса Vertex должны создаваться командой:</p>

<pre><code>v = Vertex()</code></pre>

<p>и содержать локальный атрибут:</p>

<p>_links - список связей с другими вершинами графа (список объектов класса Link).</p>

<p>Также в этом классе должно быть объект-свойство (property):</p>

<p><u>links</u> - для получения ссылки на список _links.</p>

<p>Объекты следующего класса <strong>Link</strong> должны создаваться командой:</p>

<pre><code>link = Link(v1, v2)</code></pre>

<p>где v1, v2 - объекты класса Vertex (вершины графа). Внутри каждого объекта класса Link должны формироваться следующие локальные атрибуты:</p>

<p>_v1, _v2 - ссылки на объекты класса Vertex, которые соединяются данной связью;<br>
_dist - длина связи (по умолчанию 1); это может быть длина пути, время в пути и др.</p>

<p>В классе Link должны быть объявлены следующие объекты-свойства:</p>

<p>v1 - для получения ссылки на вершину v1;<br>
v2 - для получения ссылки на вершину v2;<br>
dist - для изменения и считывания значения атрибута _dist.</p>

<p>Наконец, объекты третьего класса <strong>LinkedGraph</strong> должны создаваться командой:</p>

<pre><code>map_graph = LinkedGraph()</code></pre>

<p>В каждом объекте класса LinkedGraph должны формироваться локальные атрибуты:</p>

<p>_links - список из всех связей графа (из объектов класса Link);<br>
_vertex - список из всех вершин графа (из объектов класса Vertex).</p>

<p>В самом классе LinkedGraph необходимо объявить (как минимум) следующие методы:</p>

<p>def add_vertex(self, v): ... - для добавления новой вершины v в список _vertex (если она там отсутствует);<br>
def add_link(self, link): ... - для добавления новой связи link в список _links (если объект link с указанными вершинами в списке отсутствует);<br>
def find_path(self, start_v, stop_v): ... - для поиска кратчайшего маршрута из вершины start_v в вершину stop_v.</p>

<p>Метод find_path() должен возвращать список из вершин кратчайшего маршрута и список из связей этого же маршрута в виде кортежа: </p>

<p>([вершины кратчайшего пути], [связи между вершинами])</p>

<p>Поиск кратчайшего маршрута допустимо делать полным перебором с помощью рекурсивной функции (будем полагать, что общее число вершин в графе не превышает 100). Для тех, кто желает испытать себя в полной мере, можно реализовать алгоритм Дейкстры поиска кратчайшего пути в связном взвешенном графе.</p>

<p>В методе add_link() при добавлении новой связи следует автоматически добавлять вершины этой связи в список _vertex, если они там отсутствуют.</p>

<p>Проверку наличия связи в списке _links следует определять по вершинам этой связи. Например, если в списке имеется объект:</p>

<p>_links = [Link(v1, v2)]</p>

<p>то добавлять в него новые объекты Link(v2, v1) или Link(v1, v2) нельзя (обратите внимание у всех трех объектов будут разные id, т.е. по id определять вхождение в список нельзя).</p>

<p><strong>Подсказка:</strong> проверку на наличие существующей связи можно выполнить с использованием функции filter() и указанием нужного условия для отбора объектов.</p>

<p>Пример использования классов, применительно к схеме метро (эти строчки в программе писать не нужно):</p>

<pre><code>map_graph = LinkedGraph()

v1 = Vertex()
v2 = Vertex()
v3 = Vertex()
v4 = Vertex()
v5 = Vertex()
v6 = Vertex()
v7 = Vertex()

map_graph.add_link(Link(v1, v2))
map_graph.add_link(Link(v2, v3))
map_graph.add_link(Link(v1, v3))

map_graph.add_link(Link(v4, v5))
map_graph.add_link(Link(v6, v7))

map_graph.add_link(Link(v2, v7))
map_graph.add_link(Link(v3, v4))
map_graph.add_link(Link(v5, v6))

print(len(map_graph._links))   # 8 связей
print(len(map_graph._vertex))  # 7 вершин
path = map_graph.find_path(v1, v6)
</code></pre>

<p>Однако, в таком виде применять классы для схемы карты метро не очень удобно. Например, здесь нет указаний названий станций, а также длина каждого сегмента равна 1, что не соответствует действительности.</p>

<p>Чтобы поправить этот момент и реализовать программу поиска кратчайшего пути в метро между двумя произвольными станциями, объявите еще два дочерних класса:</p>

<p>class <strong>Station</strong>(Vertex): ... - для описания станций метро;<br>
class <strong>LinkMetro</strong>(Link): ... - для описания связей между станциями метро.</p>

<p>Объекты класса Station должны создаваться командой:</p>

<pre><code>st = Station(name)</code></pre>

<p>где name - название станции (строка). В каждом объекте класса Station должен дополнительно формироваться локальный атрибут:</p>

<p>name - название станции метро.</p>

<p>(Не забудьте в инициализаторе дочернего класса вызывать инициализатор базового класса).</p>

<p>В самом классе Station переопределите магические методы __str__() и __repr__(), чтобы они возвращали название станции метро (локальный атрибут name).</p>

<p>Объекты второго класса LinkMetro должны создаваться командой:</p>

<pre><code>link = LinkMetro(v1, v2, dist)</code></pre>

<p>где v1, v2 - вершины (станции метро); dist - расстояние между станциями (любое положительное число).</p>

<p>(Также не забывайте в инициализаторе этого дочернего класса вызывать инициализатор базового класса).</p>

<p>В результате, эти классы должны совместно работать следующим образом (эти строчки в программе писать не нужно):</p>

<pre><code>map_metro = LinkedGraph()
v1 = Station("Сретенский бульвар")
v2 = Station("Тургеневская")
v3 = Station("Чистые пруды")
v4 = Station("Лубянка")
v5 = Station("Кузнецкий мост")
v6 = Station("Китай-город 1")
v7 = Station("Китай-город 2")

map_metro.add_link(LinkMetro(v1, v2, 1))
map_metro.add_link(LinkMetro(v2, v3, 1))
map_metro.add_link(LinkMetro(v1, v3, 1))

map_metro.add_link(LinkMetro(v4, v5, 1))
map_metro.add_link(LinkMetro(v6, v7, 1))

map_metro.add_link(LinkMetro(v2, v7, 5))
map_metro.add_link(LinkMetro(v3, v4, 3))
map_metro.add_link(LinkMetro(v5, v6, 3))

print(len(map_metro._links))
print(len(map_metro._vertex))
path = map_metro.find_path(v1, v6)  # от сретенского бульвара до китай-город 1
print(path[0])    # [Сретенский бульвар, Тургеневская, Китай-город 2, Китай-город 1]
print(sum([x.dist for x in path[1]]))  # 7
</code></pre>

<p>P.S. В программе нужно объявить только классы Vertex, Link, LinkedGraph, Station, LinkMetro. На экран ничего выводить не нужно.<br>
 </p><br><br><font color="gray">Memory limit: 256 MB</font><br><font color="gray">Time limit: 15 seconds</font><br><br>