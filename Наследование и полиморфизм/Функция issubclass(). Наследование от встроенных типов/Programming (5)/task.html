<p>Видео-разбор подвига (решение смотреть только после своей попытки): <a href="https://youtu.be/0Jy6n9KESPE" rel="noopener noreferrer nofollow">https://youtu.be/0Jy6n9KESPE</a></p>

<p><strong>Подвиг 9 (на повторение).</strong> Объявите в программе базовый класс с именем <strong>IteratorAttrs</strong> для перебора всех локальных атрибутов объектов класса. Напомню, что для этого используются два магических метода:</p>

<p>__iter__() - для получения объекта-итератора (в данном случае - это сам объект self)<br>
__next__() - для перебора локальных атрибутов объекта self (используйте для этого словарь __dict__)</p>

<p>Метод __next__() на каждой итерации должен возвращать кортеж в формате: (имя атрибута, значение).</p>

<p><strong>Подсказка:</strong> здесь можно определить один метод __iter__() как функцию-генератор.</p>

<p>Объявите дочерний класс SmartPhone, объекты которого создаются командой:</p>

<pre><code>phone = SmartPhone(model, size, memory)</code></pre>

<p>где <u>model</u> - модель смартфона (строка); <u>size</u> - габариты (ширина, длина) в виде кортежа двух чисел; <u>memory</u> - размер ОЗУ (памяти), как целое число. В каждом объекте класса SmartPhone должны создаваться соответствующие локальные атрибуты: model, size, memory.</p>

<p>Благодаря наследованию от базового класса IteratorAttrs, с объектами класса SmartPhone должен выполняться оператор for:</p>

<pre><code>for attr, value in phone:
    print(attr, value)</code></pre>

<p>P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.</p><br><br><font color="gray">Memory limit: 256 MB</font><br><font color="gray">Time limit: 15 seconds</font><br><br>