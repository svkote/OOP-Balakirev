<p>Видео-разбор подвига (решение смотреть только после своей попытки): <a href="https://youtu.be/I8upOO_ZjqQ" rel="noopener noreferrer nofollow">https://youtu.be/I8upOO_ZjqQ</a></p>

<p><strong>Большой подвиг 9.</strong> Используя механизм наследования, вам поручено разработать функционал по построению моделей нейронных сетей. Общая схема модели очень простая:</p>

<p style="text-align: center;"><img alt="" height="343" name="network_layers.png" src="https://ucarecdn.com/09b5555d-c154-4581-a073-8476b8dd82af/" width="150"></p>

<p>Базовый класс Layer имеет локальный атрибут next_layer, который ссылается на следующий объект слоя нейронной сети (объект класса Layer или любого объекта дочерних классов). У последнего слоя значение next_layer = None.</p>

<p>Создавать последовательность слоев предполагается командами:</p>

<pre><code>first_layer = Layer()
next_layer = first_layer(Layer())
next_layer = next_layer(Layer())
...</code></pre>

<p>То есть, сначала создается объект first_layer класса Layer, а затем он вызывается как функция для образования связки со следующим слоем. При этом возвращается ссылка на следующий слой и переменная next_layer ссылается уже на этот следующий слой нейронной сети. И так можно создавать столько слоев, сколько необходимо.</p>

<p>В каждом объекте класса Layer также должен формироваться локальный атрибут:</p>

<p>name = 'Layer'</p>

<p>Но сам по себе класс Layer образует только связи между слоями. Никакой другой функциональности он не несет. Чтобы это исправить, в программе нужно объявить еще два дочерних класса:</p>

<p><strong>Input</strong> - формирование входного слоя нейронной сети;<br>
<strong>Dense</strong> - формирование полносвязного слоя нейронной сети.</p>

<p style="text-align: center;"><img alt="" height="166" name="network_classes.png" src="https://ucarecdn.com/618655ad-f02d-4205-b6ef-6276933ace89/" width="257"></p>

<p>Конечно, создавать нейронную сеть мы не будем. Поэтому, в классе Input нужно лишь прописать инициализатор так, чтобы его объекты создавались следующим образом:</p>

<pre><code>inp = Input(inputs)</code></pre>

<p>где <u>inputs</u> - общее число входов (целое число). Также в объектах класса Input должен автоматически формироваться атрибут:</p>

<p>name = 'Input'</p>

<p>(Не забывайте при этом, вызывать инициализатор базового класса Layer).</p>

<p>Объекты второго дочернего класса Dense предполагается создавать командой:</p>

<pre><code>dense = Dense(inputs, outputs, activation)</code></pre>

<p>где <u>inputs</u> - число входов в слой; <u>outputs</u> - число выходов слоя (целые числа); <u>activation</u> - функция активации (строка, например: 'linear', 'relu', 'sigmoid'). И в каждом объекте класса Dense также должен автоматически формироваться атрибут:</p>

<p>name = 'Dense'</p>

<p>Все эти классы совместно можно использовать следующим образом (эти строчки пример, писать не нужно):</p>

<pre><code>network = Input(128)
layer = network(Dense(network.inputs, 1024, 'linear'))
layer = layer(Dense(layer.inputs, 10, 'softmax'))</code></pre>

<p>Здесь создается три слоя нейронной сети. </p>

<p>Наконец, для перебора всех слоев с помощью цикла for, необходимо объявить отдельный класс <strong>NetworkIterator</strong> для итерирования (перебора) слоев нейронной сети следующим образом:</p>

<pre><code>for x in NetworkIterator(network):
    print(x.name)</code></pre>

<p>Здесь создается объект класса NetworkIterator. На вход передается первый объект (слой) нейронной сети. Объект этого класса является итератором, который в цикле for последовательно возвращает объекты (слои) нейронной сети.</p>

<p>P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.</p><br><br><font color="gray">Memory limit: 256 MB</font><br><font color="gray">Time limit: 15 seconds</font><br><br>