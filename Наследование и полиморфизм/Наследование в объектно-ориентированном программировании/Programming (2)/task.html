<p>Видео-разбор подвига (решение смотреть только после своей попытки): <a href="https://youtu.be/k0xvHbnTnoo" rel="noopener noreferrer nofollow">https://youtu.be/k0xvHbnTnoo</a></p>

<p><strong>Подвиг 6.</strong> Еще один пример, когда в базовом классе прописывается необходимый начальный функционал для дочерних классов.</p>

<p>Известно, что браузер (и не только) может отправлять на сервер различные типы запросов: GET, POST, PUT, DELETE и др. Каждый из этих типов запросов обрабатывается в программе на сервере своим отдельным методом. Чтобы каждый раз не прописывать все необходимые методы в классах при обработке входящих запросов, они выносятся в базовый класс и вызываются из дочерних. Выполним такой пример.</p>

<p>Пусть в программе объявлен следующий базовый класс с именем GenericView:</p>

<pre><code>class GenericView:
    def __init__(self, methods=('GET',)):
        self.methods = methods

    def get(self, request):
        return ""

    def post(self, request):
        pass

    def put(self, request):
        pass

    def delete(self, request):
        pass
</code></pre>

<p>Здесь каждый метод отвечает за обработку своего типа запроса. Параметр <u>methods</u> - это кортеж или список, состоящий из набора разрешенных запросов: строк с именами соответствующих методов (как правило, пишут заглавными буквами).<br>
Вам необходимо объявить дочерний класс с именем DetailView, объекты которого можно создавать командами:</p>

<pre><code>dv = DetailView()  # по умолчанию methods=('GET',)
dv = DetailView(methods=('PUT', 'POST'))</code></pre>

<p>Для инициализации атрибута <u>methods</u> следует вызывать инициализатор базового класса GenericView.</p>

<p>Далее, в классе DetailView нужно определить метод:</p>

<pre><code>def render_request(self, request, method): ...</code></pre>

<p>который бы имитировал выполнение поступившего на сервер запроса. Здесь <u>request</u> - словарь с набором данных запроса; <u>method</u> - тип запроса (строка: 'get' или 'post' и т.д.).</p>

<p>Например:</p>

<pre><code>html = dv.render_request({'url': 'https://site.ru/home'}, 'GET')</code></pre>

<p>должен быть обработан запрос как GET-запрос с параметром url и значением 'https://site.ru/home'. Параметр url является обязательным в словаре request для каждого запроса.</p>

<p>В методе render_request() необходимо выполнить проверку: является ли указанный метод (method) разрешенным (присутствует в коллекции methods). Если это не так, то генерировать исключение командой:</p>

<pre><code>raise TypeError('данный запрос не может быть выполнен')</code></pre>

<p>Если проверка проходит, то выполнить соответствующий метод (или get(), или post(), или put() и т.д. с возвращением результата их работы). </p>

<p><strong>Подсказка:</strong> для получения ссылки на нужный метод можно воспользоваться магическим методом __getattribute__() или аналогичной функцией getattr()).</p>

<p>Наконец, в дочернем классе DetailView следует переопределить метод get() для нужной нам обработки GET-запросов. В этом методе нужно выполнить проверку, что параметр request является словарем. Если это не так, то генерировать исключение:</p>

<pre><code>raise TypeError('request не является словарем')</code></pre>

<p>Сделать проверку, что в словаре request присутствует ключ url. Если его нет, то генерировать исключение:</p>

<pre><code>raise TypeError('request не содержит обязательного ключа url')</code></pre>

<p>Если же все проверки проходят, то вернуть строку в формате:</p>

<p>"url: &lt;request['url']&gt;"</p>

<p>Пример (эти строчки в программе писать не нужно):</p>

<pre><code>dv = DetailView()
html = dv.render_request({'url': 'https://site.ru/home'}, 'GET')   # url: https://site.ru/home</code></pre>

<p>P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.<br>
 </p><br><br><font color="gray">Memory limit: 256 MB</font><br><font color="gray">Time limit: 15 seconds</font><br><br>